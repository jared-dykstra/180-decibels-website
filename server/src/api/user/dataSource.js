import config from 'config'
import uuid from 'uuid/v1'
import { compare } from 'bcrypt'
import jwt from 'jsonwebtoken'
import { DataSource } from 'apollo-datasource'
import { UserInputError } from 'apollo-server-express'

import { addUser, findUser, addAlias } from '../../auth/dbAdapter'

const cookieOptions = () => ({
  maxAge: config.get('authDuration'),
  httpOnly: true
})

const setUserId = (id, { res }) => {
  if (res) {
    res.cookie(config.get('idCookieName'), id, {
      maxAge: config.get('idDuration'),
      httpOnly: true
    })
  }
  return id
}

const getAndSetUserProfile = ({ user, res }) => {
  const token = jwt.sign(user, config.get('jwtSecret'), {
    expiresIn: config.get('authDuration')
  })

  // If invoked via the web, set the auth token in a cookie
  if (res) {
    res.cookie(config.get('profileCookieName'), token, cookieOptions())
  }

  return token
}

const invalidateUserProfile = ({ res }) => {
  if (res) {
    // Web browsers and other compliant clients will only clear the cookie if the given options is identical to those given to res.cookie(), excluding expires and maxAge.
    res.clearCookie(config.get('profileCookieName'), cookieOptions())
  }
}

/* eslint-disable class-methods-use-this */
export default class UserAPI extends DataSource {
  // constructor(/* { store } */) {
  //   super()
  //   // this.store = store
  // }

  initialize(configuration) {
    this.context = configuration.context
  }

  /**
   * Return true/false if a given email address is already in use
   */
  async isEmailInUse({ email }) {
    // If a user is found, the email is in use
    const { user } = await findUser(email)
    return !!user
  }

  /**
   * Validate the current authentication token.  If valid, return the user & token.  Otherwise throw
   */
  async authenticate(context) {
    const { userId, userProfileToken } = context
    if (!userId) {
      // First time visiting? Generate a new user ID
      const id = uuid()
      setUserId(id, context)
    }

    let user = null
    try {
      user = await jwt.verify(userProfileToken, config.get('jwtSecret'))
    } catch (err) {
      console.warn(
        `Authentication token not found or expired: JWT error: ${err}`
      )
      throw new Error('Authentication token not found or expired.')
    }

    if (!user) {
      throw new Error('User not found.  Sign in again?')
    }
    return {
      user,
      userProfileToken
    }
  }

  /**
   * Verifies login credentials.  If valid, a new authentication token is generated.  A user and token is returned.
   * If the response `res` is available in the context, the new token is also set as a cookie
   */
  async signIn(args, context) {
    const { email, password } = args
    const { res, userId } = context
    const { user, hashedPassword } = findUser(email)

    const errorMessage = 'Invalid email or password'

    // Does the user exist?
    if (!user) {
      console.warn('signIn: user not found')
      throw new UserInputError(errorMessage, {
        invalidArgs: ['password', 'email']
      })
    }

    // Validate hashed/salted password
    const isPasswordOK = await compare(password, hashedPassword)
    if (!isPasswordOK) {
      console.warn('signIn: bad password')
      throw new UserInputError(errorMessage, {
        invalidArgs: ['password', 'email']
      })
    }

    // If the autogenerated user ID doesn't match the user retrieved via credentials,
    // then note the aliased user.  This happens when a user accesses the site using a 2nd browser or device
    // or if they have deleted cookies
    if (user.id !== userId) {
      // Store currently set user ID as an alias for the logged in user
      await addAlias(user.id, userId)
      // Change the userID to the logged in user
      await setUserId(user.id, context)
    }

    // Everything is OK
    const userProfileToken = getAndSetUserProfile({ user, res })
    return {
      user,
      userProfileToken
    }
  }

  /**
   * Invalidates user profile, but leave the user ID intact
   */
  async signOut(args, context) {
    invalidateUserProfile(context)
  }

  /**
   * Create a new user.  If valid, a new authentication token is generated.  A user and token is returned.
   * If the response `res` is available in the context, the new token is also set as a cookie
   */
  async registerUser(args, context) {
    const { user } = args
    const { userId, res } = context
    const { newUser, newUserId } = await addUser(userId, user)
    if (newUserId !== userId) {
      // The user might have been assigned a different UserID.  If so, update their session accordingly
      setUserId(newUserId, context)
    }
    const userProfileToken = getAndSetUserProfile({ user: newUser, res })
    return {
      user: newUser,
      userProfileToken
    }
  }
}
